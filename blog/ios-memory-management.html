<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS Memory Management: Weak vs Strong vs Unowned | Manan Patel</title>
    <meta name="description" content="Master iOS memory management with ARC. Learn when to use weak, strong, and unowned references to prevent memory leaks and crashes in your iOS apps.">
    <meta name="keywords" content="iOS memory management, ARC, weak references, strong references, unowned, memory leaks, retain cycles, iOS performance">
    <meta name="author" content="Manan Patel">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://mananpatel.info/blog/ios-memory-management.html">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://mananpatel.info/blog/ios-memory-management.html">
    <meta property="og:title" content="iOS Memory Management: Weak vs Strong vs Unowned">
    <meta property="og:description" content="Master iOS memory management with ARC. Learn when to use weak, strong, and unowned references.">
    <meta property="og:image" content="https://mananpatel.info/images/Headshot1.jpg">
    <meta property="article:published_time" content="2024-02-14T10:00:00Z">
    <meta property="article:author" content="Manan Patel">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mananpatel.info/blog/ios-memory-management.html">
    <meta property="twitter:title" content="iOS Memory Management: Weak vs Strong vs Unowned">
    <meta property="twitter:description" content="Master iOS memory management with ARC. Learn when to use weak, strong, and unowned references.">
    <meta property="twitter:image" content="https://mananpatel.info/images/Headshot1.jpg">
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="../index.html">Manan Patel</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#about">About</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#portfolio">Portfolio</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Blog</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#contact">Contact</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <main class="container mt-5 pt-5">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <article>
                    <header class="mb-5">
                        <div class="d-flex align-items-center gap-3 mb-3">
                            <span class="badge bg-warning px-3 py-2">Memory Management</span>
                            <small class="text-muted">
                                <i class="fas fa-calendar"></i> February 14, 2024
                            </small>
                            <small class="text-muted">
                                <i class="fas fa-clock"></i> 10 min read
                            </small>
                        </div>
                        <h1 class="display-5 fw-bold mb-3">iOS Memory Management: Weak vs Strong vs Unowned</h1>
                        <p class="lead text-muted">
                            Understanding ARC, preventing memory leaks, and choosing the right reference types for optimal performance. 
                            Real-world examples from production iOS applications.
                        </p>
                    </header>

                    <div class="mb-4">
                        <h2>Understanding Automatic Reference Counting (ARC)</h2>
                        <p>
                            Automatic Reference Counting (ARC) manages memory automatically in Swift by tracking how many references 
                            point to each object. When the reference count reaches zero, ARC deallocates the object.
                        </p>
                        <p>
                            However, ARC can't handle reference cycles automatically. This is where understanding different reference 
                            types becomes crucial for preventing memory leaks and crashes.
                        </p>
                    </div>

                    <div class="mb-4">
                        <h2>1. Strong References (Default)</h2>
                        <p>
                            Strong references are the default in Swift. They increase the reference count and prevent the object 
                            from being deallocated while the reference exists.
                        </p>

                        <h3>Basic Strong Reference Example</h3>
                        <pre><code class="language-swift">class Person {
    let name: String
    
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    
    deinit {
        print("\(name) is being deinitialized")
    }
}

// Strong reference example
var person1: Person? = Person(name: "John") // Reference count: 1
var person2: Person? = person1              // Reference count: 2

person1 = nil                               // Reference count: 1
person2 = nil                               // Reference count: 0, object is deallocated</code></pre>

                        <h3>When to Use Strong References</h3>
                        <ul>
                            <li>Parent-to-child relationships</li>
                            <li>Owner-to-owned object relationships</li>
                            <li>When you need to ensure the object stays alive</li>
                            <li>Default choice for most properties</li>
                        </ul>
                    </div>

                    <div class="mb-4">
                        <h2>2. Weak References</h2>
                        <p>
                            Weak references don't increase the reference count and automatically become nil when the referenced 
                            object is deallocated. They must always be optional variables.
                        </p>

                        <h3>Weak Reference Example</h3>
                        <pre><code class="language-swift">class Apartment {
    let number: Int
    weak var tenant: Person?  // weak reference
    
    init(number: Int) {
        self.number = number
    }
    
    deinit {
        print("Apartment \(number) is being deinitialized")
    }
}

class Person {
    let name: String
    var apartment: Apartment?  // strong reference
    
    init(name: String) {
        self.name = name
    }
    
    deinit {
        print("\(name) is being deinitialized")
    }
}

// Usage
var john: Person? = Person(name: "John")
var apartment: Apartment? = Apartment(number: 73)

john?.apartment = apartment    // Person strongly references Apartment
apartment?.tenant = john       // Apartment weakly references Person

john = nil                     // Person is deallocated
print(apartment?.tenant)       // nil - weak reference automatically set to nil</code></pre>

                        <h3>Common Weak Reference Patterns</h3>
                        <pre><code class="language-swift">// Delegate pattern
protocol NetworkManagerDelegate: AnyObject {
    func didReceiveData(_ data: Data)
    func didFailWithError(_ error: Error)
}

class NetworkManager {
    weak var delegate: NetworkManagerDelegate?  // Prevent retain cycle
    
    func fetchData() {
        // Network request logic
        delegate?.didReceiveData(responseData)
    }
}

// Closure capture lists
class ViewController: UIViewController {
    var networkManager = NetworkManager()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // ❌ Strong reference cycle
        networkManager.completion = { data in
            self.updateUI(with: data)  // self is captured strongly
        }
        
        // ✅ Weak reference prevents cycle
        networkManager.completion = { [weak self] data in
            self?.updateUI(with: data)  // self is captured weakly
        }
    }
    
    private func updateUI(with data: Data) {
        // Update UI
    }
}</code></pre>

                        <h3>When to Use Weak References</h3>
                        <ul>
                            <li>Delegate properties</li>
                            <li>Child-to-parent references</li>
                            <li>Breaking retain cycles in closures</li>
                            <li>Observer patterns</li>
                            <li>When the referenced object might be deallocated</li>
                        </ul>
                    </div>

                    <div class="mb-4">
                        <h2>3. Unowned References</h2>
                        <p>
                            Unowned references don't increase the reference count but assume the referenced object will always 
                            be available. They're not optional and will crash if accessed after the object is deallocated.
                        </p>

                        <h3>Unowned Reference Example</h3>
                        <pre><code class="language-swift">class Customer {
    let name: String
    var creditCard: CreditCard?
    
    init(name: String) {
        self.name = name
    }
    
    deinit {
        print("\(name) is being deinitialized")
    }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer  // unowned reference
    
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    
    deinit {
        print("Card #\(number) is being deinitialized")
    }
}

// Usage
var john: Customer? = Customer(name: "John Appleseed")
john?.creditCard = CreditCard(number: 1234_5678_9012_3456, customer: john!)

john = nil  // Both Customer and CreditCard are deallocated</code></pre>

                        <h3>Unowned vs Weak Decision Tree</h3>
                        <pre><code class="language-swift">// Use weak when the reference might become nil
class Parent {
    var children: [Child] = []
}

class Child {
    weak var parent: Parent?  // Child might outlive parent
}

// Use unowned when the reference should never become nil
class View {
    unowned let controller: ViewController  // View should never outlive controller
    
    init(controller: ViewController) {
        self.controller = controller
    }
}

// Real-world example: Network request with callback
class APIClient {
    func fetchUser(completion: @escaping (User?) -> Void) {
        // Network request
    }
}

class UserViewController: UIViewController {
    let apiClient = APIClient()
    
    func loadUser() {
        // Use weak because ViewController might be deallocated before request completes
        apiClient.fetchUser { [weak self] user in
            self?.updateUI(with: user)
        }
    }
    
    func loadCriticalData() {
        // Use unowned only if you're certain ViewController will exist
        // when the closure executes (generally not recommended for async operations)
        apiClient.fetchUser { [unowned self] user in
            self.updateUI(with: user)  // Will crash if self is deallocated
        }
    }
}</code></pre>

                        <h3>When to Use Unowned References</h3>
                        <ul>
                            <li>When the referenced object will always outlive the current object</li>
                            <li>One-to-one relationships where objects have the same lifetime</li>
                            <li>When you want to avoid optional unwrapping</li>
                            <li>Performance-critical code (slight performance advantage over weak)</li>
                        </ul>
                    </div>

                    <div class="mb-4">
                        <h2>Memory Leaks in Real Applications</h2>
                        
                        <h3>Common Retain Cycle Scenarios</h3>
                        <pre><code class="language-swift">// 1. Timer retain cycles
class TimerViewController: UIViewController {
    var timer: Timer?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // ❌ Timer strongly retains target
        timer = Timer.scheduledTimer(timeInterval: 1.0, 
                                   target: self, 
                                   selector: #selector(timerFired), 
                                   userInfo: nil, 
                                   repeats: true)
    }
    
    // ✅ Use weak reference or invalidate timer
    deinit {
        timer?.invalidate()  // Essential to break the cycle
    }
    
    @objc func timerFired() {
        // Update UI
    }
}

// 2. Notification center retain cycles
class NotificationViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // ❌ Can create retain cycle with certain notification patterns
        NotificationCenter.default.addObserver(
            self, 
            selector: #selector(handleNotification), 
            name: .init("CustomNotification"), 
            object: nil
        )
    }
    
    // ✅ Always remove observers
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    @objc func handleNotification() {
        // Handle notification
    }
}

// 3. URLSession retain cycles
class NetworkViewController: UIViewController {
    func fetchData() {
        // ❌ Potential retain cycle
        URLSession.shared.dataTask(with: url) { data, response, error in
            self.processData(data)  // Strong capture of self
        }.resume()
        
        // ✅ Use weak capture
        URLSession.shared.dataTask(with: url) { [weak self] data, response, error in
            self?.processData(data)
        }.resume()
    }
}</code></pre>

                        <h3>Advanced Memory Management Patterns</h3>
                        <pre><code class="language-swift">// Custom weak reference wrapper
class WeakWrapper<T: AnyObject> {
    weak var value: T?
    
    init(_ value: T) {
        self.value = value
    }
}

// Weak array for observers
class EventEmitter {
    private var observers: [WeakWrapper<EventObserver>] = []
    
    func addObserver(_ observer: EventObserver) {
        observers.append(WeakWrapper(observer))
    }
    
    func removeObserver(_ observer: EventObserver) {
        observers.removeAll { $0.value === observer }
    }
    
    func emit() {
        // Clean up nil references
        observers = observers.filter { $0.value != nil }
        
        // Notify active observers
        observers.forEach { $0.value?.handleEvent() }
    }
}

// Lazy initialization with unowned
class ExpensiveResource {
    unowned let owner: ResourceOwner
    
    init(owner: ResourceOwner) {
        self.owner = owner
        // Expensive setup
    }
}

class ResourceOwner {
    lazy var resource: ExpensiveResource = ExpensiveResource(owner: self)
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h2>Debugging Memory Issues</h2>
                        
                        <h3>Using Instruments</h3>
                        <ol>
                            <li><strong>Leaks Instrument:</strong> Detects retain cycles and memory leaks</li>
                            <li><strong>Allocations Instrument:</strong> Tracks memory usage patterns</li>
                            <li><strong>VM Tracker:</strong> Monitors virtual memory usage</li>
                        </ol>

                        <h3>Debug Techniques</h3>
                        <pre><code class="language-swift">// Add deinit methods to verify deallocation
class MyViewController: UIViewController {
    deinit {
        print("MyViewController deallocated")
        // This should print when the VC is dismissed
        // If it doesn't, you have a retain cycle
    }
}

// Use memory debugging tools
// In Xcode: Product → Profile → Leaks
// Runtime debugging: Environment Variables → MallocStackLogging = 1

// Weak reference debugging
class DebuggableWeakRef<T: AnyObject> {
    weak var value: T? {
        didSet {
            if value == nil {
                print("Weak reference became nil")
            }
        }
    }
    
    init(_ value: T) {
        self.value = value
    }
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h2>Best Practices Summary</h2>
                        
                        <div class="table-responsive">
                            <table class="table table-striped">
                                <thead>
                                    <tr>
                                        <th>Reference Type</th>
                                        <th>Use When</th>
                                        <th>Characteristics</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Strong</strong></td>
                                        <td>Parent-to-child, ownership</td>
                                        <td>Default, increases retain count</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Weak</strong></td>
                                        <td>Delegates, child-to-parent</td>
                                        <td>Optional, becomes nil automatically</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Unowned</strong></td>
                                        <td>Equal lifetimes, performance critical</td>
                                        <td>Non-optional, crashes if accessed after dealloc</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <h3>Quick Decision Guide</h3>
                        <ol>
                            <li><strong>Default to strong</strong> unless you have a specific reason</li>
                            <li><strong>Use weak for delegates</strong> and back-references</li>
                            <li><strong>Use weak in closures</strong> that might outlive the object</li>
                            <li><strong>Use unowned sparingly</strong> and only when you're certain of lifetimes</li>
                            <li><strong>Always test memory management</strong> with Instruments</li>
                        </ol>
                    </div>

                    <div class="alert alert-danger">
                        <h4><i class="fas fa-exclamation-triangle"></i> Common Mistakes to Avoid</h4>
                        <ul class="mb-0">
                            <li>Using unowned when the object might be deallocated (causes crashes)</li>
                            <li>Forgetting to use weak in delegate properties</li>
                            <li>Creating retain cycles with closures</li>
                            <li>Not invalidating timers in deinit</li>
                            <li>Assuming ARC handles all memory management automatically</li>
                        </ul>
                    </div>

                    <div class="alert alert-info">
                        <h4><i class="fas fa-lightbulb"></i> Production Experience</h4>
                        <p class="mb-0">
                            These patterns and debugging techniques are documented in my 
                            <a href="https://github.com/MananPatel95/iOS-Notes" target="_blank" rel="noopener">iOS-Notes repository</a>, 
                            including examples of memory leaks I've encountered and fixed in production applications.
                        </p>
                    </div>

                    <footer class="mt-5 pt-4 border-top">
                        <div class="row">
                            <div class="col-md-6">
                                <h5>Share this article</h5>
                                <div class="d-flex gap-2">
                                    <a href="https://twitter.com/intent/tweet?text=iOS Memory Management: Weak vs Strong vs Unowned&url=https://mananpatel.info/blog/ios-memory-management.html" 
                                       class="btn btn-outline-primary btn-sm" target="_blank" rel="noopener">
                                        <i class="fab fa-twitter"></i> Twitter
                                    </a>
                                    <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://mananpatel.info/blog/ios-memory-management.html" 
                                       class="btn btn-outline-primary btn-sm" target="_blank" rel="noopener">
                                        <i class="fab fa-linkedin"></i> LinkedIn
                                    </a>
                                </div>
                            </div>
                            <div class="col-md-6 text-md-end">
                                <h5>Related Posts</h5>
                                <ul class="list-unstyled">
                                    <li><a href="swift-concurrency-multithreading.html">Swift Concurrency and Multithreading</a></li>
                                    <li><a href="ios-architecture-patterns.html">iOS Architecture Patterns</a></li>
                                </ul>
                            </div>
                        </div>
                    </footer>
                </article>
            </div>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 